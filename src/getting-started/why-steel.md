# Why Steel?

So why might a developer choose Steel? This section focuses entirely on Steel’s strengths:

* **Lower Compute Unit Usage:** Steel is designed to execute with a smaller compute footprint. It optimizes how memory is handled and avoids doing work that isn’t necessary. For example, it can operate on account data in place (without copying it around), which saves on extra operations and thus conserves compute units. This efficiency means a Steel-based program can include more complex logic or process more data without running into Solana’s compute limits.

* **Flexibility:** Steel is unopinionated and gives you a lot of freedom in how you implement your program. Unlike a rigid framework, it doesn’t force a specific project structure or restrict what patterns you use for accounts and instructions. You can choose any serialization format for your data or implement custom account checks to fit your needs. This flexibility is useful for unconventional or advanced use cases — essentially, you’re not fighting the framework when you need something outside the default patterns.

* **Near-Native Rust Syntax:** Writing contracts in Steel feels like writing normal Rust code for Solana. There’s very little special syntax beyond a few helper macros. You primarily work with familiar Rust constructs (structs, enums, and the Solana SDK types) and then use Steel’s library to glue them into a Solana program. Because the code stays close to standard Rust, it’s easier to understand in terms of what’s actually happening on-chain. In other words, Steel code closely mirrors the underlying Solana runtime expectations, which can make debugging and optimization more straightforward.

* **Rust-Native Testing:** Steel allows you to test your smart contract logic entirely in Rust. You can write unit tests or integration tests using Rust’s `#[test]` framework alongside Solana’s program testing utilities. This is beneficial because you don’t need to switch to a different language or environment to verify your program’s behavior. All your development — from writing contract code to writing tests for that code — happens in Rust, letting you take advantage of Rust’s strong type system and testing tools to catch issues early.

* **Less Abstraction, More Control:** Steel provides helpful building blocks but doesn’t obscure the underlying Solana system. You still directly manage things like account data layout, error handling, and even cross-program calls (though Steel offers utilities to assist with these). Because there’s less of an abstraction layer in between, you always have a clear picture of what the code is doing with your accounts and data. This transparency means that if you need to optimize or handle an edge case in a custom way, you can do so directly. In summary, Steel trades some of the hand-holding convenience for giving developers a finer level of control over their programs, which can be empowering when you need to squeeze out performance or implement custom logic.
